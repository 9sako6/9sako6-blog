---
title: "No.910 素数部分列 (★2.5)"
description:
tags:
  - 競技プログラミング
  - yukicoder
  - 素数
  - 貪欲
  - 部分列
  - 部分列の削除
created_at: 2019-10-20
updated_at: 
draft: false
---

# 問題

[No.910 素数部分列](https://yukicoder.me/problems/no/910)

# 解法
文字列の構成要素で、素数は`3`, `5`, `7`。
まずは、これらを1つずつ削除すれば良さそう。
なぜなら、`3`, `5`, `7`を残しておくことによって今後の操作で削除回数が増えるなんてことはないから。
（どうやって証明するのかはわからないけど、、、）

次に、残っている`1`, `9`からなる文字列について考える。
これらを使って作れる素数は`11`, `19`がある。
でも、実はもっとあって、`991`も素数である。`99991`も素数である。

ここで考えるべきなのは`11`, `19`, `991`系をどの順番で消していくかである。
`19`, `991`系の存在から、`9`はいくつあっても素数になれないが、`1`があると素数になりうる。
なので、`1`はなるべく`9`と一緒に消したい気持ちになる。`11`を消すのは一番最後にする。

`19`, `991`系のどっちを先に消すかであるが、`19`を先に消すのが良い。
例えば、`99191`を考えた時、先に`991`を消すと削除回数は1回だが、先に`19`を消すと2回になる。

ということで、`19`を消すと`9`の左側にある`1`は全部消えるから、残る文字列は`999...111...`みたいなものになる。

次に`991`系を消すが、消すのは`991`だけでよい。（例えば、`99991`を考えた時、`991`を消すのも`99991`を消すのも回数は同じである。
例えば、`999911`を考えた時、`99991`を消すと1回だが、`991`を消と2回である。つまり、`991`になって消える可能性があるのだがら、むやみに`9`を消費する必要はない。）

最後に、残った`11`を削除すれば良い。


```c++
#include <iostream>

using namespace std;
#define rep(i, n) for (int i = 0; i < (int)(n); i++)

int main() {
  cin.tie(0);
  ios::sync_with_stdio(false);
  int n;
  cin >> n;
  string s;
  cin >> s;
  int ans = 0;
  int cnt_1 = 0;
  int cnt_9 = 0;
  rep(i, n) {
    if ((s[i] != '1') && (s[i] != '9')) {
      // 3, 5, 7を消す
      ++ans;
    } else if (s[i] == '1') {
      cnt_1++;
    } else if (s[i] == '9') {
      // 19を消す
      cnt_9++;
      if (cnt_1 > 0) {
        cnt_1--;
        cnt_9--;
        ans++;
      }
    }
  }
  // 991を消す
  int cnt_991 = min(cnt_9 / 2, cnt_1);
  ans += cnt_991;
  // 11を消す
  ans += (cnt_1 - cnt_991) / 2;
  cout << ans << endl;

  return 0;
}
```

[submission](https://yukicoder.me/submissions/391932)



# 学び
`991`って素数なんですね。（本番では`991`が素数だと気づくのが遅すぎた。）
複雑な実装をして`WA`しまくったので、シンプルな実装に落ちるまで煮詰めてから実装をはじめなさーい

部分列`19`を消す処理が頭いいので覚えたい。

```c++
// 19を消す
cnt_9++;
if (cnt_1 > 0) {
  cnt_1--;
  cnt_9--;
  ans++;
}
```
