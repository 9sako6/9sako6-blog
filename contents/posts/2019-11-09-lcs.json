{
  "title": "Longest common substring problem (DP解法)",
  "description": "2つの文字列の最長共通部分文字列を求める問題です。最長共通部分文字列とは、2つの文字列に含まれる連続した文字列のうち、長さが最大のものです...",
  "tags": [
    "文字列",
    "DP",
    "部分列",
    "部分文字列"
  ],
  "created_at": "2019-11-09T00:00:00.000Z",
  "updated_at": "2019-11-12T00:00:00.000Z",
  "draft": false,
  "bodyContent": "**Longest common substring problem**とは、2つの文字列に共通する最長の部分文字列（最長共通部分文字列）（そのもの、あるいは長さ）を求める問題です。最長共通部分文字列とは、2つの文字列に含まれる**連続した**文字列のうち、長さが最大のものです。\n例えば、`abcd`, `becd` なら `cd`です。\n\n\n紛らわしいのですが、**Longest common subsequence problem** (**LCS**, 最長共通部分列問題)とは別物です。LCSの場合は順序が維持されていれば連続している必要がありません。例えば、 `abcd`, `becd`なら `bcd`です。\n\n# 問題\n2つの文字列\\\\(S\\\\), \\\\(T\\\\)に共通する(連続する)部分文字列の最大長を求めよ。\n\n# 解法\nDPで解きます。計算量は\\\\(O(|S| \\times |T|)\\\\)です。\n\n（Suffix Arrayを使ってもっと計算量を改善できるみたいですが、本記事では扱いません。\n改善した際のverify用リンク：[SPOJ.com - Problem LCS](https://www.spoj.com/problems/LCS/)）\n\nまず、状態の定義です。添字は1-indexedとします。\n\n- `dp[i][j]` := Sのi文字目, Tのj文字目が共通部分文字列の何文字目か\n\n\n以下のdpテーブルに値を埋めていきます。以降、`abcdefg`, `cdeg`について考えます。\n\nまた、便宜上0文字目に空文字が存在するものとします。\n\n![table1](/posts_images/2019-11-09-lcs/1.png)\n\n\n\ni = 0, j = 0の場合は共通部分文字列がつくれないので全て0で埋まります。\n\n![table1](/posts_images/2019-11-09-lcs/2.png)\n\n\n\nSのi文字目とTのj文字目が不一致の場合は0を埋めます。\n\n![table1](/posts_images/2019-11-09-lcs/3.png)\n\n\n\n\nSのi文字目とTのj文字目が一致する場合、`dp[i-1][j-1] + 1`を埋めます。\nつまり、この場合`c`という文字で一致しているので、左上のマス(`dp[i-1][j-1]`)に`+1`した値を埋めます。\n\n![table1](/posts_images/2019-11-09-lcs/4.png)\n\n\nテーブルを全て埋めると以下のようになります。\nSのi文字目とTのj文字目が一致する場合の遷移を行う際に、`result = max(result, dp[i][j])`としておけば最大長が求まります。\n\n![table1](/posts_images/2019-11-09-lcs/5.png)\n\n\n\n```ruby\ndef longest_common_substring(s1, s2)\n  n = s1.size\n  m = s2.size\n  dp = Array.new(n + 1) { Array.new(m + 1, 0) }\n  result = 0\n  (n + 1).times do |i|\n    (m + 1).times do |j|\n      # i, j : 1-indexed\n      if i == 0 || j == 0\n        dp[i][j] = 0\n      elsif s1[i - 1] == s2[j - 1]\n        dp[i][j] = dp[i - 1][j - 1] + 1\n        result = [dp[i][j], result].max\n      else\n        dp[i][j] = 0\n      end\n    end\n  end\n  result\nend\n```\n\n# 参考\n1. [アルゴリズム1000本ノック #2. Longest common substrings](https://qiita.com/_rdtr/items/b80cecac36451dbaee60)",
  "bodyHtml": "<p><strong>Longest common substring problem</strong>とは、2つの文字列に共通する最長の部分文字列（最長共通部分文字列）（そのもの、あるいは長さ）を求める問題です。最長共通部分文字列とは、2つの文字列に含まれる<strong>連続した</strong>文字列のうち、長さが最大のものです。\n例えば、<code>abcd</code>, <code>becd</code> なら <code>cd</code>です。</p>\n<p>紛らわしいのですが、<strong>Longest common subsequence problem</strong> (<strong>LCS</strong>, 最長共通部分列問題)とは別物です。LCSの場合は順序が維持されていれば連続している必要がありません。例えば、 <code>abcd</code>, <code>becd</code>なら <code>bcd</code>です。</p>\n<h1>問題</h1>\n<p>2つの文字列\\(S\\), \\(T\\)に共通する(連続する)部分文字列の最大長を求めよ。</p>\n<h1>解法</h1>\n<p>DPで解きます。計算量は\\(O(|S| \\times |T|)\\)です。</p>\n<p>（Suffix Arrayを使ってもっと計算量を改善できるみたいですが、本記事では扱いません。\n改善した際のverify用リンク：<a href=\"https://www.spoj.com/problems/LCS/\">SPOJ.com - Problem LCS</a>）</p>\n<p>まず、状態の定義です。添字は1-indexedとします。</p>\n<ul>\n<li><code>dp[i][j]</code> := Sのi文字目, Tのj文字目が共通部分文字列の何文字目か</li>\n</ul>\n<p>以下のdpテーブルに値を埋めていきます。以降、<code>abcdefg</code>, <code>cdeg</code>について考えます。</p>\n<p>また、便宜上0文字目に空文字が存在するものとします。</p>\n<p><img src=\"/posts_images/2019-11-09-lcs/1.png\" alt=\"table1\"></p>\n<p>i = 0, j = 0の場合は共通部分文字列がつくれないので全て0で埋まります。</p>\n<p><img src=\"/posts_images/2019-11-09-lcs/2.png\" alt=\"table1\"></p>\n<p>Sのi文字目とTのj文字目が不一致の場合は0を埋めます。</p>\n<p><img src=\"/posts_images/2019-11-09-lcs/3.png\" alt=\"table1\"></p>\n<p>Sのi文字目とTのj文字目が一致する場合、<code>dp[i-1][j-1] + 1</code>を埋めます。\nつまり、この場合<code>c</code>という文字で一致しているので、左上のマス(<code>dp[i-1][j-1]</code>)に<code>+1</code>した値を埋めます。</p>\n<p><img src=\"/posts_images/2019-11-09-lcs/4.png\" alt=\"table1\"></p>\n<p>テーブルを全て埋めると以下のようになります。\nSのi文字目とTのj文字目が一致する場合の遷移を行う際に、<code>result = max(result, dp[i][j])</code>としておけば最大長が求まります。</p>\n<p><img src=\"/posts_images/2019-11-09-lcs/5.png\" alt=\"table1\"></p>\n<pre><code class=\"hljs\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">longest_common_substring</span><span class=\"hljs-params\">(s1, s2)</span></span>\n  n = s1.size\n  m = s2.size\n  dp = Array.new(n + <span class=\"hljs-number\">1</span>) { Array.new(m + <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">0</span>) }\n  result = <span class=\"hljs-number\">0</span>\n  (n + <span class=\"hljs-number\">1</span>).times <span class=\"hljs-keyword\">do</span> <span class=\"hljs-params\">|i|</span>\n    (m + <span class=\"hljs-number\">1</span>).times <span class=\"hljs-keyword\">do</span> <span class=\"hljs-params\">|j|</span>\n      <span class=\"hljs-comment\"># i, j : 1-indexed</span>\n      <span class=\"hljs-keyword\">if</span> i == <span class=\"hljs-number\">0</span> <span class=\"hljs-params\">||</span> j == <span class=\"hljs-number\">0</span>\n        dp[i][j] = <span class=\"hljs-number\">0</span>\n      <span class=\"hljs-keyword\">elsif</span> s1[i - <span class=\"hljs-number\">1</span>] == s2[j - <span class=\"hljs-number\">1</span>]\n        dp[i][j] = dp[i - <span class=\"hljs-number\">1</span>][j - <span class=\"hljs-number\">1</span>] + <span class=\"hljs-number\">1</span>\n        result = [dp[i][j], result].max\n      <span class=\"hljs-keyword\">else</span>\n        dp[i][j] = <span class=\"hljs-number\">0</span>\n      <span class=\"hljs-keyword\">end</span>\n    <span class=\"hljs-keyword\">end</span>\n  <span class=\"hljs-keyword\">end</span>\n  result\n<span class=\"hljs-keyword\">end</span></code></pre><h1>参考</h1>\n<ol>\n<li><a href=\"https://qiita.com/_rdtr/items/b80cecac36451dbaee60\">アルゴリズム1000本ノック #2. Longest common substrings</a></li>\n</ol>\n",
  "dir": "contents/posts",
  "base": "2019-11-09-lcs.json",
  "ext": ".json",
  "sourceBase": "2019-11-09-lcs.md",
  "sourceExt": ".md"
}