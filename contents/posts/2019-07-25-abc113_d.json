{
  "title": "ABC113 D - Number of Amidakuji (400点)",
  "description": null,
  "tags": [
    "競技プログラミング",
    "Ruby",
    "DP",
    "AtCoder",
    "典型",
    "割った余り"
  ],
  "created_at": "2019-07-25T00:00:00.000Z",
  "updated_at": "2019-11-09T00:00:00.000Z",
  "draft": false,
  "bodyContent": "優秀なフレンズの助言をもらいながらACできたので、忘れないうちに記事にします。\n\n# 問題\n\n[D - Number of Amidakuji](https://atcoder.jp/contests/abc113/tasks/abc113_d)\n\n> **概要**(適当なのでちゃんと公式の問題文を読んでね)  \n縦棒の長さ\\\\(H\\\\)と本数\\\\(W\\\\)が与えられる。縦棒の間に好きに横線を引いて、あみだくじを作る。\\\\(1\\\\)番目の棒の上端から, 横線があれば必ずそれを通るというルールで下へたどったときに、最終的にたどり着く縦棒の番号が\\\\(K\\\\)となるような「正しいあみだくじ」の本数を\\\\(1000000007\\\\)で割った余りを求めなさい。  \n**制約**  \n・\\\\(1 \\leq H \\leq 100 \\\\)  \n・\\\\(1 \\leq W \\leq 8 \\\\)  \n・\\\\(1 \\leq K \\leq W \\\\)\n\n# 考察\n考えの流れ\n- ある高さにおける横線の引き方は高々\\\\(2^{(8-1)}\\\\)通り\n- ある高さ\\\\(h\\\\)の\\\\(w\\\\)本目に至るのが何通りかわかっていたら\\\\(h+1\\\\)についても計算できるんじゃないか\n  - 各高さについて分割して考えられそう\n- ある高さ\\\\(h\\\\)の\\\\(w\\\\)本目に至る状態をまとめて扱えそう\n- DPかな\n- 計算量を見積もる。ある高さにおいて、全ての横線の引き方である\\\\(2^{(8-1)}\\\\)通りの状態を考え、それぞれがあみだくじの要件を満たしているかを計\\\\(W\\\\)本について調べる。これを全ての高さ(\\\\(\\leq 100 \\\\))について行うので、\\\\(O(2^7 \\times 8 \\times 100 = 2^{10} \\times 100 \\simeq 10^5) \\\\)で間に合いそう\n\n上記のような考察でDPっぽいことがわかったので、状態と遷移を考えます。\n\\\\(dp[h][w]\\\\)を、高さ\\\\(h\\\\)の\\\\(w\\\\)番目(0-indexed)に至るのに何通りあるか、と定めます。\n\n遷移を考えます。\n今、高さ\\\\(h\\\\)、\\\\(w\\\\)番目の横線にいるとします。ここに至るまでに\\\\(dp[h][w]\\\\)通り存在します。\n\n![transition](/posts_images/2019-07-25-abc113_d/1.png)\n\n\\\\(w+1\\\\)に向かう横線があれば、\\\\(w+1\\\\)番目の横線に移動して次の高さに進みます。\\\\(dp[h+1][w+1] += dp[h][w] \\\\)\n\n![transition](/posts_images/2019-07-25-abc113_d/2.png)\n\n\\\\(w-1\\\\)に向かう横線があれば、\\\\(w-1\\\\)番目の横線に移動して次の高さに進みます。\\\\(dp[h+1][w-1] += dp[h][w] \\\\)\n\n![transition](/posts_images/2019-07-25-abc113_d/3.png)\n\n両隣に横線がなかったら、同じ\\\\(w\\\\)番目のまま次の高さに進みます。\n\\\\(dp[h+1][w] += dp[h][w] \\\\)\n\n![transition](/posts_images/2019-07-25-abc113_d/4.png)\n\nちなみに、両隣に横線があることはありません。正しくないあみだくじだからです。そのような正しくないあみだくじは予め弾いておきます。\n\n初期条件は\\\\(dp[0][0]=1\\\\)です。高さ\\\\(0\\\\)、すなわち、まだどの高さにも移動してないとき、\\\\(0\\\\)番目の横棒にいるのは\\\\(1\\\\)通りだからです。\n\n\n```ruby\nH, W, K = gets.split.map(&:to_i)\nMOD = 10 ** 9 + 7\ndp = Array.new(H + 1) { Array.new(W, 0) }\ndp[0][0] = 1\nH.times do |h|\n  # ある高さにおいて、2^(W-1)通りの横線の引き方がある\n  (0...(1 << (W - 1))).each do |bit|\n    # check\n    # 正しくないあみだくじを弾く\n    # 1が連続して2つあったらアウト\n    flag = false\n    (1...W).each do |i|\n      if bit[i] == 1 && bit[i - 1] == 1\n        flag = true\n      end\n    end\n    next if flag\n    # transition\n    # 横線をそれぞれ調べて遷移\n    W.times do |w|\n      if w != W - 1 && bit[w] == 1\n        target = w + 1\n      elsif w != 0 && bit[w - 1] == 1\n        target = w - 1\n      else\n        target = w\n      end\n      dp[h + 1][target] = (dp[h + 1][target] + dp[h][w]) % MOD\n    end\n  end\nend\nputs dp[H][K - 1]\n\n```\n\n[submission](https://atcoder.jp/contests/abc113/submissions/6530229)\n\n# 学び\nDPを使うところまで漕ぎ着ければ、DPに慣れてる人なら解けそう。\nDPに至る思考として\n- 分割して解けないか\n- まとめて扱えないか\n\nみたいなのがありそう。\n\nDPの状態と遷移自体はシンプルなので教育的なDP問題だと思う。",
  "bodyHtml": "<p>優秀なフレンズの助言をもらいながらACできたので、忘れないうちに記事にします。</p>\n<h1>問題</h1>\n<p><a href=\"https://atcoder.jp/contests/abc113/tasks/abc113_d\">D - Number of Amidakuji</a></p>\n<blockquote>\n<p><strong>概要</strong>(適当なのでちゃんと公式の問題文を読んでね)<br>\n縦棒の長さ\\(H\\)と本数\\(W\\)が与えられる。縦棒の間に好きに横線を引いて、あみだくじを作る。\\(1\\)番目の棒の上端から, 横線があれば必ずそれを通るというルールで下へたどったときに、最終的にたどり着く縦棒の番号が\\(K\\)となるような「正しいあみだくじ」の本数を\\(1000000007\\)で割った余りを求めなさい。<br>\n<strong>制約</strong><br>\n・\\(1 \\leq H \\leq 100 \\)<br>\n・\\(1 \\leq W \\leq 8 \\)<br>\n・\\(1 \\leq K \\leq W \\)</p>\n</blockquote>\n<h1>考察</h1>\n<p>考えの流れ</p>\n<ul>\n<li>ある高さにおける横線の引き方は高々\\(2^{(8-1)}\\)通り</li>\n<li>ある高さ\\(h\\)の\\(w\\)本目に至るのが何通りかわかっていたら\\(h+1\\)についても計算できるんじゃないか\n<ul>\n<li>各高さについて分割して考えられそう</li>\n</ul>\n</li>\n<li>ある高さ\\(h\\)の\\(w\\)本目に至る状態をまとめて扱えそう</li>\n<li>DPかな</li>\n<li>計算量を見積もる。ある高さにおいて、全ての横線の引き方である\\(2^{(8-1)}\\)通りの状態を考え、それぞれがあみだくじの要件を満たしているかを計\\(W\\)本について調べる。これを全ての高さ(\\(\\leq 100 \\))について行うので、\\(O(2^7 \\times 8 \\times 100 = 2^{10} \\times 100 \\simeq 10^5) \\)で間に合いそう</li>\n</ul>\n<p>上記のような考察でDPっぽいことがわかったので、状態と遷移を考えます。\n\\(dp[h][w]\\)を、高さ\\(h\\)の\\(w\\)番目(0-indexed)に至るのに何通りあるか、と定めます。</p>\n<p>遷移を考えます。\n今、高さ\\(h\\)、\\(w\\)番目の横線にいるとします。ここに至るまでに\\(dp[h][w]\\)通り存在します。</p>\n<p><img src=\"/posts_images/2019-07-25-abc113_d/1.png\" alt=\"transition\"></p>\n<p>\\(w+1\\)に向かう横線があれば、\\(w+1\\)番目の横線に移動して次の高さに進みます。\\(dp[h+1][w+1] += dp[h][w] \\)</p>\n<p><img src=\"/posts_images/2019-07-25-abc113_d/2.png\" alt=\"transition\"></p>\n<p>\\(w-1\\)に向かう横線があれば、\\(w-1\\)番目の横線に移動して次の高さに進みます。\\(dp[h+1][w-1] += dp[h][w] \\)</p>\n<p><img src=\"/posts_images/2019-07-25-abc113_d/3.png\" alt=\"transition\"></p>\n<p>両隣に横線がなかったら、同じ\\(w\\)番目のまま次の高さに進みます。\n\\(dp[h+1][w] += dp[h][w] \\)</p>\n<p><img src=\"/posts_images/2019-07-25-abc113_d/4.png\" alt=\"transition\"></p>\n<p>ちなみに、両隣に横線があることはありません。正しくないあみだくじだからです。そのような正しくないあみだくじは予め弾いておきます。</p>\n<p>初期条件は\\(dp[0][0]=1\\)です。高さ\\(0\\)、すなわち、まだどの高さにも移動してないとき、\\(0\\)番目の横棒にいるのは\\(1\\)通りだからです。</p>\n<pre><code class=\"hljs\">H, W, K = gets.split.map(&amp;<span class=\"hljs-symbol\">:to_i</span>)\nMOD = <span class=\"hljs-number\">10</span> ** <span class=\"hljs-number\">9</span> + <span class=\"hljs-number\">7</span>\ndp = Array.new(H + <span class=\"hljs-number\">1</span>) { Array.new(W, <span class=\"hljs-number\">0</span>) }\ndp[<span class=\"hljs-number\">0</span>][<span class=\"hljs-number\">0</span>] = <span class=\"hljs-number\">1</span>\nH.times <span class=\"hljs-keyword\">do</span> <span class=\"hljs-params\">|h|</span>\n  <span class=\"hljs-comment\"># ある高さにおいて、2^(W-1)通りの横線の引き方がある</span>\n  (<span class=\"hljs-number\">0</span>...(<span class=\"hljs-number\">1</span> &lt;&lt; (W - <span class=\"hljs-number\">1</span>))).each <span class=\"hljs-keyword\">do</span> <span class=\"hljs-params\">|bit|</span>\n    <span class=\"hljs-comment\"># check</span>\n    <span class=\"hljs-comment\"># 正しくないあみだくじを弾く</span>\n    <span class=\"hljs-comment\"># 1が連続して2つあったらアウト</span>\n    flag = <span class=\"hljs-literal\">false</span>\n    (<span class=\"hljs-number\">1</span>...W).each <span class=\"hljs-keyword\">do</span> <span class=\"hljs-params\">|i|</span>\n      <span class=\"hljs-keyword\">if</span> bit[i] == <span class=\"hljs-number\">1</span> &amp;&amp; bit[i - <span class=\"hljs-number\">1</span>] == <span class=\"hljs-number\">1</span>\n        flag = <span class=\"hljs-literal\">true</span>\n      <span class=\"hljs-keyword\">end</span>\n    <span class=\"hljs-keyword\">end</span>\n    <span class=\"hljs-keyword\">next</span> <span class=\"hljs-keyword\">if</span> flag\n    <span class=\"hljs-comment\"># transition</span>\n    <span class=\"hljs-comment\"># 横線をそれぞれ調べて遷移</span>\n    W.times <span class=\"hljs-keyword\">do</span> <span class=\"hljs-params\">|w|</span>\n      <span class=\"hljs-keyword\">if</span> w != W - <span class=\"hljs-number\">1</span> &amp;&amp; bit[w] == <span class=\"hljs-number\">1</span>\n        target = w + <span class=\"hljs-number\">1</span>\n      <span class=\"hljs-keyword\">elsif</span> w != <span class=\"hljs-number\">0</span> &amp;&amp; bit[w - <span class=\"hljs-number\">1</span>] == <span class=\"hljs-number\">1</span>\n        target = w - <span class=\"hljs-number\">1</span>\n      <span class=\"hljs-keyword\">else</span>\n        target = w\n      <span class=\"hljs-keyword\">end</span>\n      dp[h + <span class=\"hljs-number\">1</span>][target] = (dp[h + <span class=\"hljs-number\">1</span>][target] + dp[h][w]) % MOD\n    <span class=\"hljs-keyword\">end</span>\n  <span class=\"hljs-keyword\">end</span>\n<span class=\"hljs-keyword\">end</span>\nputs dp[H][K - <span class=\"hljs-number\">1</span>]</code></pre><p><a href=\"https://atcoder.jp/contests/abc113/submissions/6530229\">submission</a></p>\n<h1>学び</h1>\n<p>DPを使うところまで漕ぎ着ければ、DPに慣れてる人なら解けそう。\nDPに至る思考として</p>\n<ul>\n<li>分割して解けないか</li>\n<li>まとめて扱えないか</li>\n</ul>\n<p>みたいなのがありそう。</p>\n<p>DPの状態と遷移自体はシンプルなので教育的なDP問題だと思う。</p>\n",
  "dir": "contents/posts",
  "base": "2019-07-25-abc113_d.json",
  "ext": ".json",
  "sourceBase": "2019-07-25-abc113_d.md",
  "sourceExt": ".md"
}