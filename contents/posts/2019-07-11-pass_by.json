{
  "title": "値渡し、参照渡し、参照の値渡し",
  "description": null,
  "tags": [
    "値渡し",
    "参照渡し",
    "参照の値渡し",
    "C++",
    "Ruby"
  ],
  "created_at": "2019-07-11T00:00:00.000Z",
  "updated_at": null,
  "draft": true,
  "bodyContent": "本記事では、関数への引数の渡し方である`値渡し`、`参照渡し`、`参照の値渡し`を説明します。\nこれらは全てのプログラミング言語に共通の概念です。\n正確に理解しないと意図しない挙動を生み出してしまう場合があります。\n\n例えば、巨大な値（超長い文字列とか）を関数に`値渡し`していると毎回コピーが作られてスタックオーバーフローするかもしれません。\nなので`参照渡し`を使うとか、その辺の感覚を養うためにも理解したい概念です。\n\nまた、RubyやJavaでは上記2つとは似て非なる`参照の値渡し`によって変数を渡します。\n\n# 仮引数と実引数\n事前知識を説明しますが、不要な場合は読み飛ばしてください。\n\n\n\n# 値渡し\n\n値渡しでは、値をコピーした新しいオブジェクトを作って渡します。\n\n以下は、変数`b`に変数`a`を値渡ししする例です。\n\n```c++\n#include <string>\n#include <iostream>\n\nusing namespace std;\n\nint main(){\n    string a = \"hoge\";\n    string b = a; // 値渡し\n    b[3] = 'E'; // 破壊的な変更\n    cout << a << endl; // hoge\n    cout << b << endl; // hogE\n    return 0;\n}\n```\n\n\n`b`に破壊的な変更を加えても、`a`は元のままです。\n`b`は`a`をコピーした全く別のオブジェクトだからです。\n\n# 参照渡し\n\n全く同じものに対する別名を作るような感じです。\n\n```c++\n#include <string>\n#include <iostream>\n\nusing namespace std;\n\nint main(){\n    string a = \"hoge\";\n    string &b = a; // 参照渡し\n    b[3] = 'E'; // 破壊的な変更\n    cout << a << endl; // hogE\n    cout << b << endl; // hogE\n\n    string c = \"foo\";\n    b = c;      // 代入\n    cout << a << endl; // foo\n    cout << b << endl; // foo\n    return 0;\n}\n```\n\n`b`に破壊的な変更を加えると、`a`も変更されます。\nなぜなら、`a`と`b`は名前が違うだけで、指しているメモリ上の場所も値も同じものだからです。\n`b`に新しいオブジェクトを代入した場合も同様に`a`も変更されます。\n\n# 参照の値渡し\n\n参照渡しと似ていますが代入した時の挙動が違います。こうなるのは、「これまでとはオブジェクトに対する考え方そのものが違うから」と思うとわかりやすいかもしれません。\n\nちなみに、Rubyでは全てが参照の値渡しです。\n\n\n|          | `b`に破壊的変更 | `b`に代入 |\n| -------- | ---------------------- | ---- |\n|値渡し     |  `a`そのまま。`b`変わる。 |  `a`そのまま。`b`変わる。  |\n|参照渡し   |  `a`変わる。`b`変わる。  | `a`変わる。`b`変わる。  |\n|参照の値渡し|  `a`変わる。`b`変わる。  |  `a`そのまま。`b`変わる。  |",
  "bodyHtml": "<p>本記事では、関数への引数の渡し方である<code>値渡し</code>、<code>参照渡し</code>、<code>参照の値渡し</code>を説明します。\nこれらは全てのプログラミング言語に共通の概念です。\n正確に理解しないと意図しない挙動を生み出してしまう場合があります。</p>\n<p>例えば、巨大な値（超長い文字列とか）を関数に<code>値渡し</code>していると毎回コピーが作られてスタックオーバーフローするかもしれません。\nなので<code>参照渡し</code>を使うとか、その辺の感覚を養うためにも理解したい概念です。</p>\n<p>また、RubyやJavaでは上記2つとは似て非なる<code>参照の値渡し</code>によって変数を渡します。</p>\n<h1>仮引数と実引数</h1>\n<p>事前知識を説明しますが、不要な場合は読み飛ばしてください。</p>\n<h1>値渡し</h1>\n<p>値渡しでは、値をコピーした新しいオブジェクトを作って渡します。</p>\n<p>以下は、変数<code>b</code>に変数<code>a</code>を値渡ししする例です。</p>\n<pre><code class=\"hljs\"><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">include</span> <span class=\"hljs-meta-string\">&lt;string&gt;</span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">include</span> <span class=\"hljs-meta-string\">&lt;iostream&gt;</span></span>\n\n<span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> <span class=\"hljs-built_in\">std</span>;\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span>{\n    <span class=\"hljs-built_in\">string</span> a = <span class=\"hljs-string\">\"hoge\"</span>;\n    <span class=\"hljs-built_in\">string</span> b = a; <span class=\"hljs-comment\">// 値渡し</span>\n    b[<span class=\"hljs-number\">3</span>] = <span class=\"hljs-string\">'E'</span>; <span class=\"hljs-comment\">// 破壊的な変更</span>\n    <span class=\"hljs-built_in\">cout</span> &lt;&lt; a &lt;&lt; <span class=\"hljs-built_in\">endl</span>; <span class=\"hljs-comment\">// hoge</span>\n    <span class=\"hljs-built_in\">cout</span> &lt;&lt; b &lt;&lt; <span class=\"hljs-built_in\">endl</span>; <span class=\"hljs-comment\">// hogE</span>\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;\n}</code></pre><p><code>b</code>に破壊的な変更を加えても、<code>a</code>は元のままです。\n<code>b</code>は<code>a</code>をコピーした全く別のオブジェクトだからです。</p>\n<h1>参照渡し</h1>\n<p>全く同じものに対する別名を作るような感じです。</p>\n<pre><code class=\"hljs\"><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">include</span> <span class=\"hljs-meta-string\">&lt;string&gt;</span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">include</span> <span class=\"hljs-meta-string\">&lt;iostream&gt;</span></span>\n\n<span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> <span class=\"hljs-built_in\">std</span>;\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span>{\n    <span class=\"hljs-built_in\">string</span> a = <span class=\"hljs-string\">\"hoge\"</span>;\n    <span class=\"hljs-built_in\">string</span> &amp;b = a; <span class=\"hljs-comment\">// 参照渡し</span>\n    b[<span class=\"hljs-number\">3</span>] = <span class=\"hljs-string\">'E'</span>; <span class=\"hljs-comment\">// 破壊的な変更</span>\n    <span class=\"hljs-built_in\">cout</span> &lt;&lt; a &lt;&lt; <span class=\"hljs-built_in\">endl</span>; <span class=\"hljs-comment\">// hogE</span>\n    <span class=\"hljs-built_in\">cout</span> &lt;&lt; b &lt;&lt; <span class=\"hljs-built_in\">endl</span>; <span class=\"hljs-comment\">// hogE</span>\n\n    <span class=\"hljs-built_in\">string</span> c = <span class=\"hljs-string\">\"foo\"</span>;\n    b = c;      <span class=\"hljs-comment\">// 代入</span>\n    <span class=\"hljs-built_in\">cout</span> &lt;&lt; a &lt;&lt; <span class=\"hljs-built_in\">endl</span>; <span class=\"hljs-comment\">// foo</span>\n    <span class=\"hljs-built_in\">cout</span> &lt;&lt; b &lt;&lt; <span class=\"hljs-built_in\">endl</span>; <span class=\"hljs-comment\">// foo</span>\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;\n}</code></pre><p><code>b</code>に破壊的な変更を加えると、<code>a</code>も変更されます。\nなぜなら、<code>a</code>と<code>b</code>は名前が違うだけで、指しているメモリ上の場所も値も同じものだからです。\n<code>b</code>に新しいオブジェクトを代入した場合も同様に<code>a</code>も変更されます。</p>\n<h1>参照の値渡し</h1>\n<p>参照渡しと似ていますが代入した時の挙動が違います。こうなるのは、「これまでとはオブジェクトに対する考え方そのものが違うから」と思うとわかりやすいかもしれません。</p>\n<p>ちなみに、Rubyでは全てが参照の値渡しです。</p>\n<table>\n<thead>\n<tr>\n<th></th>\n<th><code>b</code>に破壊的変更</th>\n<th><code>b</code>に代入</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>値渡し</td>\n<td><code>a</code>そのまま。<code>b</code>変わる。</td>\n<td><code>a</code>そのまま。<code>b</code>変わる。</td>\n</tr>\n<tr>\n<td>参照渡し</td>\n<td><code>a</code>変わる。<code>b</code>変わる。</td>\n<td><code>a</code>変わる。<code>b</code>変わる。</td>\n</tr>\n<tr>\n<td>参照の値渡し</td>\n<td><code>a</code>変わる。<code>b</code>変わる。</td>\n<td><code>a</code>そのまま。<code>b</code>変わる。</td>\n</tr>\n</tbody>\n</table>\n",
  "dir": "contents/posts",
  "base": "2019-07-11-pass_by.json",
  "ext": ".json",
  "sourceBase": "2019-07-11-pass_by.md",
  "sourceExt": ".md"
}