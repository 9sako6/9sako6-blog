{
  "title": "ABC040 C - 柱柱柱柱柱 (100点)",
  "description": "超典型的な動的計画法練習問題！",
  "tags": [
    "競技プログラミング",
    "AtCoder",
    "Python3",
    "DP",
    "ABC-C"
  ],
  "created_at": "2019-05-22T00:00:00.000Z",
  "updated_at": null,
  "draft": false,
  "bodyContent": "# 問題\n\n[C - 柱柱柱柱柱](https://atcoder.jp/contests/abc040/tasks/abc040_c)\n\n\\\\(N\\\\)本の柱が並んでいる。\n\\\\(1\\\\)本目の柱からスタートし、右へ柱を渡っていき\\\\(N\\\\)本目の柱まで行きたい。\n移動するときには、現在いる柱の高さと、移動後の柱の高さの差の絶対値ぶんのコストがかかる。\n\\\\(N\\\\)本目の柱まで行く最小のコストを求める。\n\n# 解法\nDP（動的計画法）で解く。けんちょんさんのDP入門記事「[動的計画法超入門！ Educational DP Contest の A ～ E 問題の解説と類題集 - Qiita](https://qiita.com/drken/items/dc53c683d6de8aeacf5a#%E5%88%A5%E8%A7%A3-1-%E9%85%8D%E3%82%8B-dp)」によると、「貰うDP」、「配るDP」というのがある。この問題に当てはめると、それぞれ以下のことを意味する。\n\n- 貰うDP：\\\\(i-2\\\\), \\\\(i-1\\\\)から\\\\(i\\\\)への遷移を考える\n- 配るDP：\\\\(i\\\\)から\\\\(i+1\\\\), \\\\(i+2\\\\)の遷移を考える\n\nこの2つの方法で解いてみる。\n\n## 解法1：貰うDP\n要素を\\\\(INF\\\\)で初期化した\\\\(dp[]\\\\)を用意する。ただし、0-indexedとする。\nこれに伴い、問題では「\\\\(1\\\\)本目, \\\\(2\\\\)本目, ..., \\\\\\(N\\\\)本目」と数えていた柱を、\n「\\\\(0\\\\)本目, \\\\(1\\\\)本目, ..., \\\\\\(N-1\\\\)本目」と数えることにする。\n\\\\(dp[i]\\\\)は「\\\\(0\\\\)本目の柱から\\\\(i\\\\)本目の柱へ移動するまでの合計コストの最小値」となるようにする。\nこの\\\\(dp[i]\\\\)を求めていく。明らかに\\\\(dp[0]=0\\\\)である。\\\\(0\\\\)本目の柱から\\\\(0\\\\)本目の柱に移動するコストは\\\\(0\\\\)だからである。\nまた、柱\\\\(i\\\\)の高さを\\\\(a_i\\\\)とすると、\\\\(dp[1]=abs(a_0 - a_1)\\\\)である。\n\n\\\\(i \\geq 2\\\\)の場合を求めていく。\nこのDPにおける重要な考え方は「\\\\(i\\\\)本目の柱に到達した時点で\\\\(i-2\\\\), \\\\(i-1\\\\)本目までの合計最小コストはわかっている」というもの。\nつまり、\\\\(i-2\\\\)本目までの合計最小コストは\\\\(dp[i-2]\\\\)に、\n\\\\(i-1\\\\)本目までの合計最小コストは\\\\(dp[i-1]\\\\)に入っているんだという意識が大事。\nこれを踏まえて\n- \\\\(i-1\\\\)から\\\\(i\\\\)に移動するとき、合計最小コスト\\\\(cost1 = dp[i-1]+|a_i - a_{i-1}|\\\\)\n- \\\\(i-2\\\\)から\\\\(i\\\\)に移動するとき、合計最小コスト\\\\(cost2 = dp[i-2]+|a_i - a_{i-2}|\\\\)\n\n\\\\(dp[i]\\\\)は上記のうち小さいほうを採用すればよく、\\\\(dp[i]=min(cost1, cost2)\\\\)となる。\nこのようにして各柱についてのコストが求まり、\\\\(dp[N-1]\\\\)が答えとなる。\n\n[submission](https://atcoder.jp/contests/abc040/submissions/5101300)\n\n## 解法2：配るDP\n\n```python\nINF = 1<<60\nn=int(input())\nh=list(map(int, input().split()))+[INF]*2 # 範囲外にアクセスしないように2個足してる\ndp=[INF]*(n+2) # 範囲外にアクセスしないように2個足してる\ndp[0]=0\ndp[1]=abs(h[0]-h[1])\nfor i in range(0, n):\n    dp[i+1] = min(dp[i+1], dp[i]+abs(h[i]-h[i+1]))\n    dp[i+2] = min(dp[i+2], dp[i]+abs(h[i]-h[i+2]))\nprint(dp[n-1])\n```\n\n[submission](https://atcoder.jp/contests/abc040/submissions/5186185)\n\n# 学び\n基本的なDPなので押さえておきたい。また、最小化問題なので\\\\(INF\\\\)で初期化することに注意。",
  "bodyHtml": "<h1>問題</h1>\n<p><a href=\"https://atcoder.jp/contests/abc040/tasks/abc040_c\">C - 柱柱柱柱柱</a></p>\n<p>\\(N\\)本の柱が並んでいる。\n\\(1\\)本目の柱からスタートし、右へ柱を渡っていき\\(N\\)本目の柱まで行きたい。\n移動するときには、現在いる柱の高さと、移動後の柱の高さの差の絶対値ぶんのコストがかかる。\n\\(N\\)本目の柱まで行く最小のコストを求める。</p>\n<h1>解法</h1>\n<p>DP（動的計画法）で解く。けんちょんさんのDP入門記事「<a href=\"https://qiita.com/drken/items/dc53c683d6de8aeacf5a#%E5%88%A5%E8%A7%A3-1-%E9%85%8D%E3%82%8B-dp\">動的計画法超入門！ Educational DP Contest の A ～ E 問題の解説と類題集 - Qiita</a>」によると、「貰うDP」、「配るDP」というのがある。この問題に当てはめると、それぞれ以下のことを意味する。</p>\n<ul>\n<li>貰うDP：\\(i-2\\), \\(i-1\\)から\\(i\\)への遷移を考える</li>\n<li>配るDP：\\(i\\)から\\(i+1\\), \\(i+2\\)の遷移を考える</li>\n</ul>\n<p>この2つの方法で解いてみる。</p>\n<h2>解法1：貰うDP</h2>\n<p>要素を\\(INF\\)で初期化した\\(dp[]\\)を用意する。ただし、0-indexedとする。\nこれに伴い、問題では「\\(1\\)本目, \\(2\\)本目, ..., \\(N\\)本目」と数えていた柱を、\n「\\(0\\)本目, \\(1\\)本目, ..., \\(N-1\\)本目」と数えることにする。\n\\(dp[i]\\)は「\\(0\\)本目の柱から\\(i\\)本目の柱へ移動するまでの合計コストの最小値」となるようにする。\nこの\\(dp[i]\\)を求めていく。明らかに\\(dp[0]=0\\)である。\\(0\\)本目の柱から\\(0\\)本目の柱に移動するコストは\\(0\\)だからである。\nまた、柱\\(i\\)の高さを\\(a_i\\)とすると、\\(dp[1]=abs(a_0 - a_1)\\)である。</p>\n<p>\\(i \\geq 2\\)の場合を求めていく。\nこのDPにおける重要な考え方は「\\(i\\)本目の柱に到達した時点で\\(i-2\\), \\(i-1\\)本目までの合計最小コストはわかっている」というもの。\nつまり、\\(i-2\\)本目までの合計最小コストは\\(dp[i-2]\\)に、\n\\(i-1\\)本目までの合計最小コストは\\(dp[i-1]\\)に入っているんだという意識が大事。\nこれを踏まえて</p>\n<ul>\n<li>\\(i-1\\)から\\(i\\)に移動するとき、合計最小コスト\\(cost1 = dp[i-1]+|a_i - a_{i-1}|\\)</li>\n<li>\\(i-2\\)から\\(i\\)に移動するとき、合計最小コスト\\(cost2 = dp[i-2]+|a_i - a_{i-2}|\\)</li>\n</ul>\n<p>\\(dp[i]\\)は上記のうち小さいほうを採用すればよく、\\(dp[i]=min(cost1, cost2)\\)となる。\nこのようにして各柱についてのコストが求まり、\\(dp[N-1]\\)が答えとなる。</p>\n<p><a href=\"https://atcoder.jp/contests/abc040/submissions/5101300\">submission</a></p>\n<h2>解法2：配るDP</h2>\n<pre><code class=\"hljs\">INF = <span class=\"hljs-number\">1</span>&lt;&lt;<span class=\"hljs-number\">60</span>\nn=int(input())\nh=list(map(int, input().split()))+[INF]*<span class=\"hljs-number\">2</span> <span class=\"hljs-comment\"># 範囲外にアクセスしないように2個足してる</span>\ndp=[INF]*(n+<span class=\"hljs-number\">2</span>) <span class=\"hljs-comment\"># 範囲外にアクセスしないように2個足してる</span>\ndp[<span class=\"hljs-number\">0</span>]=<span class=\"hljs-number\">0</span>\ndp[<span class=\"hljs-number\">1</span>]=abs(h[<span class=\"hljs-number\">0</span>]-h[<span class=\"hljs-number\">1</span>])\n<span class=\"hljs-keyword\">for</span> i <span class=\"hljs-keyword\">in</span> range(<span class=\"hljs-number\">0</span>, n):\n    dp[i+<span class=\"hljs-number\">1</span>] = min(dp[i+<span class=\"hljs-number\">1</span>], dp[i]+abs(h[i]-h[i+<span class=\"hljs-number\">1</span>]))\n    dp[i+<span class=\"hljs-number\">2</span>] = min(dp[i+<span class=\"hljs-number\">2</span>], dp[i]+abs(h[i]-h[i+<span class=\"hljs-number\">2</span>]))\nprint(dp[n<span class=\"hljs-number\">-1</span>])</code></pre><p><a href=\"https://atcoder.jp/contests/abc040/submissions/5186185\">submission</a></p>\n<h1>学び</h1>\n<p>基本的なDPなので押さえておきたい。また、最小化問題なので\\(INF\\)で初期化することに注意。</p>\n",
  "dir": "contents/posts",
  "base": "2019-05-22-abc040_c.json",
  "ext": ".json",
  "sourceBase": "2019-05-22-abc040_c.md",
  "sourceExt": ".md"
}